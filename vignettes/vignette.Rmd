---
title: "STUtility - Vignette"
author:
- Joseph Bergenstråhle, Royal Institute of Technology (KTH)
- Ludvig Larsson, Royal Institute of Technology (KTH)
date: ''
output:
  html_document:
    theme: darkly
    css: style.css
    number_sections: false
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: true
  pdf_document:
    number_sections: false
    toc: yes
    toc_depth: 3
---

<style type="text/css">
div.main-container {
  background-color: #000000 !important;
  max-width: 1400px;
  margin-left: auto;
  margin-right: auto;
}
</style>
<style>
#TOC {
  top: 5%;
  opacity: 0.8;
  width: 400px;
  color: black;
}
#TOC:hover {
  opacity: 1;
}
</style>
<style> code, pre{
  background-color: #000000 !important;
  color: white !important;
}
</style>
<style> 
body {
  color: white
}
</style>



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Installation

Using devtools, execute the following from the R console:
<br>
```{r, eval=FALSE}

devtools::install_github(
    "jbergenstrahle/STUtility"
   , build_opts = c("--no-resave-data", "--no-manual")
)

```

```{r load_library, echo=FALSE}

library(STutility)

#TODO: addera workflow att ifall man ska använda seurat funktioern med features, så får man först lägga in det från meta datan som ligger i STaffli objektet

```

# Background

## The Spatial Transcriptomics method 

---

The tutorial aims to lay the foundation of best practice for ST data analysis. At such, the user is probably already familiar with the underlying method and a detailed description is therefore found elsewhere. Interested readers are pointed to the original publication from 2016 (https://science.sciencemag.org/content/353/6294/78). 

![Schematic Spatial Transcriptomics](st_method_1.png)

In short, there are two main output components from an ST experiment; (i) the gene expression data and (ii) the image data. 

All the steps explained in this guide could be performed with only the expression data. However, the image data, apart from being fundamental to the biological interpretation, is used to filter out capture-spots that lies directly under the tissue. This filtering excludes the unwanted data points, lowering the memory burden of the data objects created as well as removing informational noise. 

An introductory animation is available on our website: http://www.spatialtranscriptomicsresearch.org/

### Spot adjustment and selection

The gene expression data consists of a count matrix with genes in rows and capture "spots" in columns. Each spot represents a small area on an ST array from which the captured transcripts have been barcoded with a unique sequence. The unique barcode makes it possible to map the transcripts onto a spatial position on the tissue section and would be equivalent to a cell specific barcode in scRNA-seq data but can tag a mixture of transcripts from multiple cells. The spatial position of a spot is an (x, y) coordinate that defines the centroid of the spot area. These spatial coordinates are stored in the spot ids (column names) and allows us to visualize gene expression (and other spot features) in the array grid system. However, if you want to overlay a visualization on top the HE image you want to make sure that the spot coordinates are exact in relation to morphological features of the image. When the spots are printed onto the ST array surface, they will sometimes deviate from the (x, y) coordinates given by the spot ids and should therefore be adjusted. In addition to the spot adjustment, you will also need to label the spots that are located directly under the tissue. Spot adjustment and selection can be done automatically using our [ST spot detector](https://github.com/SpatialTranscriptomicsResearch/st_spot_detector) web tool which outputs a table of adjusted coordinates and labels for the spots under tissue.

## A note on using STUtility for multiple sample analysis

The STUtility tool was developed with the goal of multiple sample inputs. As with all biological data, using multiple samples add power to the analysis and is a necessity to enable comprehensive insight which otherwise suffers from stochastic uncertainty. Within this vignette, we display how you can input multiple samples, look for aggravating circumstances like batch effects and missing data, apply methods to correct such if present, get a holistic picture of your data as well as conduct more in depth analysis in various ways.

## A note on the fundamental backbone of STUtility - The Seurat workflow

We have extensively tried different methods and workflows for handling ST data. While all roads lead to Rome, as of the date of this writing we find the Seurat approach [https://satijalab.org/seurat/] to be the most suited for this type of data. Seurat is an R package designed for single-cell RNAseq data. Obviously, this deviates from the data that the ST technology currently produce, as the resolution on the array implies that each capture-spot consists of transcripts originating from multiple cells. Nevertheless, the characteristics of the ST data resembles that of scRNAseq to a large extent. 

## A note about the new 10X Visium array

In late 2018, the company Spatial Transcriptomics was acquired by 10X Genomics, which since then have been developing the new version of the technological platform that our research group have been using in the past years, called _Visium_. There are some changes in the experimental protocol for the Visium, and the type of output and subsequently input to this R tool. Since our goal is to have this R tool compatible to past and future versions of the technology, both are supported. If you are working with the Visium platform, please see [The 10X Visium platform]. 

## A note about the naming conventions used

For users familiar with the Seurat workflow, there are a number of Seruat plotting functions, e.g. `Seurat::FeaturePlot()`, those plotting functions all have a "ST version", which is called upon by adding "ST." prior to the original function name e.g. `STutility::ST.FeaturePlot()`.

The external STUtility functions are following a PascalCase convention. 

# Getting started

## Original ST platform

### Input files

After a typical ST experiment, we have the following three output files:

1. Count file
2. Spot detector output 
3. H&E image

To use the full range of functions within STUtility, all three files are needed for each sample. However, all data analysis steps that do not involve the H&E image can be performed with only the count file as input. 

---

To follow along this tutorial, download the test data set at TODO:[insert test data set link]. The downloadable content consists of count files, output from our spot detector tool, H&E stained images as well as an "infoTable" to read in the files into R.

### Prepare data

The recommended method to read the files into R is via the creation of a "infoTable", which is a table with three columns "samples", "spotfiles" and "imgs". 
<br>
```{r example_infotable, echo=FALSE, eval=FALSE}

samples <- c("Path to samples 1 ", "Path to samples 2")
spotfiles <- c("Path to spotfile 1", "Path to spotfile 2")
imgs <- c("Path to H&E image 1", "Path to H&E image 2")
data.frame(samples, spotfiles, imgs)
```

These columns are *mandatory* to include in the infoTable. However, spotfiles and imgs can be left empty if the user do not wish to include the image in the analysis workflow.

any number of _extra_ columns can be added with metadata. This information can then be used to e.g. coloring of plots and subsetting. These columns can be named as you like. 

Lets load the provided infoTable
<br>
```{r package_infotable, cache = TRUE}

infoTable <- read.table("~/STUtility/inst/extdata/metaData_mmBrain.csv", sep=";", header=T, stringsAsFactors = F)[c(1, 5, 6, 7), ]

```

### Loading data

The provided count matrix consists of EnsambleIDs (with version id) as gene names. Gene symbols are often a preference for easier reading, and we provide a transformation table accordingly. 
<br>
```{r annotation, cache = TRUE}
#Transformation table for geneIDs
ensids <- read.table(file = list.files(system.file("extdata", package = "STutility"), full.names = T, pattern = "mouse_genes"), header = T, sep = "\t", stringsAsFactors = F)

```

We are now ready to load our samples and create a "seurat" object. 

Here, we demonstrate the creation of the seurat object, while also including some filtering by only keeping the genes that are found in at least 5 capture spots and a total count value >= 100. We also only keep the spots that contains >= 500 total transcripts. As already mentioned, we recommend users to include a column named "imgs" with paths to the HE stained histological images. The images are not loaded into the Seurat object to begin with but are neccessary if you want to overlay any gene expression values. The "spotfiles" column should include paths to "selection tables" which are files containing tabular information about spots located under the tissue as well as "pixel coordinates" coordinates specifying where the spots are centered on the corresponding HE images. Without this information, you will not be able to overlay gene expression on top of the image properly so we highly recommend you to include this information into the infoTable. Finally, the "samples" column should provide paths to the gene count matrices (either .tsv or .h5 format).

If you wish to include other meta data you can just add any number of columns into your infoTable which will be stored in the meta.data slot of the Seurat object.

Note that you have to specify which platform the data comes from. The default platform is 10X Visium but if you wish to run data from another platform there is support for "1k" and "2k" arrays. You can also mix datasets from different platforms by specifying one of; "Visium", "1k" or "2k" in a separate column of the infoTable named "platform". You just have to make sure that the datasets have gene symbols which follows the same nomenclature.
<br>
```{r read_input_1, eval=TRUE, cache=TRUE}
#DOUBLE CHECK SO THAT THIS IS CORRECT NOW

#TODO: add warnings if ids missmatch. Check that ids are in the data.frame ...
se <- InputFromTable(infotable = infoTable, 
                      min.gene.count = 100, 
                      min.gene.spots = 5,
                      min.spot.count = 500, 
                      annotation = ensids, 
                      platform = "2k", 
                      pattern.remove = "^mt-")

```


## 10X Visium platform

### Input files

After running the 10X SpaceRanger pipeline, the output includes:

1. Count file in H5 format
2. Barcode position file 
3. H&E image

To use the full range of functions within STutility, all three files are needed for each sample. However, all data analysis steps that do not involve the H&E image can be performed with only the count file as input. 

---

To follow along this tutorial, download the test data set at TODO:[insert test data set link]. The downloadable content consists of count files, output from our spot detector tool, H&E stained images as well as an "infoTable" to read in the files into R.

### 10x infoTable

The same format is used as the original ST platform, see \@ref(The-infoTable)
<br>
```{r infotable2, cache=TRUE}

samples <- list.files(path = "~/Hippocampus_Visium/", recursive = T, pattern = "filtered_feature_bc_matrix.h5", full.names = T)
imgs <- list.files(path = "~/Hippocampus_Visium/", recursive = T, pattern = "hires_image.png", full.names = T)
spotfiles <- list.files(path = "~/Hippocampus_Visium/", recursive = T, pattern = "list.txt", full.names = T)

infoTable <- data.frame(imgs, samples, spotfiles, sample_id = c("Hippo_A", "Hippo_B"), stringsAsFactors = F)

```

### Loading 10X data

To read in the 10x Visium .h5 files, the package `hdf5r` needs to be installed (`BiocManager::install("hdf5r")`). By default 10X Visium output format implies setting `transpose=F`. [There is a specified scaling factor for the H&E image. The picture with suffix "high_res" uses the default scaling factor of 0.1039393. However, is other pictures are used, specify the scaling factor when calling the _InputFromTable()_ function. All scaling factors are found in the scalefactors_json.json which you have in your 10X output folder] (OBS CHECK HOW THE WORKFLOW 10X IS SUPPOSED TO BE)
<br>
```{r read_input_2, cache=TRUE}

se <- InputFromTable(infotable = infoTable, 
                      min.gene.count = 100, 
                      min.gene.spots = 5,
                      min.spot.count = 500)

```


# Loading and handling images

With the Seurat object created, we are ready to load the H&E images from the file paths provided in the infoTable. The LoadImages() function allow you to load the images into the Seurat object and will automatically save a scaled down version of each image that you can use for plotting.

You should be aware that the resolution is by default very low (400 pixels wide). The reason for this is that STUtility makes it possible to apply various image transformations to the images, but since these processing steps are slow and requires significant amounts of memory, it is much faster to learn the transformations on a small image and later apply the transformations to a higher resolution image. See the image processing section of this vignette for more details.

<br>
```{r load_images, echo=TRUE, eval=FALSE}

se <- LoadImages(se)

```
<br>
OBS: We have noted that some systems experience memory problems due to large size image information not being cleared when removing old objects. If this is the case, the user can set `time.resolve=TRUE`, which will add a small garbage collection step to avoid this issue.

NOTE: time.resolve is set to TRUE as default in the current version. This will imply that the process takes approx. 5sec longer per sample. Turn this off if annoyed. 

---

The core of an ST experiment is the interplay between quantitative RNAseq data and qualitative image data. Working in R, the handling of image information and plotting of multiple samples can get a bit cumbersome, especially if the images are of higher resolution. Typically, we rarely find much use of plotting multiple samples together with the tissue images within this framework. Instead, the general tip is to perform the various plots using only the expression data, and after finding anything of interest that warrants further analysis - take out that sample and plot it individually together with the stained tissue image. 

For example, we can visualize the number of RNA features and RNA counts on the ST array coordinates and quickly verify where we capture more material from the tissue.

NOTE: see the end of the vignette how to handle plotting if you are missing image/spot-files. 
<br>
```{r load_se, include=FALSE}

# Read in the processed Seurat object so that all computationally demanding downstream steps can be skipped
se <- readRDS(file = "../se_object")

```

```{r plot_features1, fig.height=12, fig.width=12, out.width = '100%'}
# TODO: make sure that levels are set in facets

ST.FeaturePlot(object = se, 
               features = c("nFeature_RNA", "nCount_RNA"), 
               cols = c("black", "dark blue", "cyan", "yellow", "red", "dark red"),
               ncol = 2, 
               grid.ncol = 1, 
               pt.size = 0.5, 
               dark.theme = T)

```
<br>
To overlay a spatial feature heatmaps on top of the HE image we use the FeatureOverlay() function. Handling large images gets clumsy so we recommend to work with down-scaled versions of the images that takes up less memory.
<br>

```{r overlay_features1, fig.width = 6, fig.height = 6, out.width = '100%'}

FeatureOverlay(se, 
               features = "Cck", 
               pt.size = 0.5, 
               pt.alpha = 0.5, 
               cols = c("black", "dark blue", "cyan", "yellow", "red", "dark red"), 
               dark.theme = T, 
               type = "raw")

```
<br>
You can see that by default, the first sample was selected for the feature overlay. If you wish to visualize another sample you can specify the `sample.index` parameter. If you wish to plot several features side by side, you can just specify as many as you want.
<br>
```{r overlay_features_2, fig.width = 12, fig.height = 12, out.width = '100%'}

FeatureOverlay(se, 
               features = c("Cck", "Calb2", "Dcn", "Nrgn"), 
               pt.size = 0.5,
               pt.alpha = 0.5, 
               cols = c("black", "dark blue", "cyan", "yellow", "red", "dark red"), 
               dark.theme = T, 
               type = "raw")

```

<br>
Another neat feature that can be useful for visualization purposes is to mask the background of the HE images. The function `MaskImages()` can be used to remove the background currently works well for tissues with a clearly defined border. Since masking is a non trivial problem, it is possible that the masking will fail for certain tissue types. If this happens you can try to modify the parameters in `MaskImages()` to see if you can obtain better results. 

NOTE that the image procesing methods have been optimized for small images and if you have loaded images in higher resolution there is a greater risk that some steps will fail. If you still wish to use images with higher resolution there are instructions on how to do this in the Resolution section below.
<br>
```{r mask_images, eval=FALSE}

se <- MaskImages(object = se)

```
<br>
There are 5 types of images which can be stored into the Seurat object; "raw", "masked", "masked.masks", "processed" and "processed.masks". "raw" represents the original HE images without any modifications. In the "masked" images, the background have been removed using a mask which is stored in "masked.masks". Similarly, the "processed"  images are also masked using "processed.masks" but have been further modified by applying rigid transformations such as rotations and shifts.

You can look at the HE images using the ImagePlot() function.The ImagePlot function will automatically label the samples from 1 to N where N is the total number of samples. If you are running the function within RStudio you can take advantage of the Viewer panel to explore the images. Setting method="raster" and the plot function will use the default plotting device in R. You can also change the layout of the images by forcing a different number of columns by setting ncols.
<br>
```{r image_types, fig.width=11, fig.height=6, out.width = '100%'}

# Plot HE images
ImagePlot(se, ncols = 2, method = "raster", type = "raw", darken = T) # Raw image
ImagePlot(se, ncols = 2, method = "raster", type = "masked", darken = T) # Masked image
ImagePlot(se, ncols = 2, method = "raster", type = "masked.masks") # Mask

```

### Individual transformations to images

If you follow along the test set in this vignette, you will notice that the samples are not quite aligned with respect to each other on the array. We have implemented three different method to align images; `AlignImages()`, `WarpImages()` and `ManualAlignImages()`.

#### Automatic alignment

The automatic alignment method (`AlignImages()`) first tries to detect the tissue edges from each image. By default, the first image (`reference.index = 1`) is used as a reference but you can specify any sample with the `reference.index`option. Then, for each image, a transformation matrix is learned that can be used to map coordinates to the reference image. This alignment method will sometimes fail and in that case you can align the images manually instead using the `ManualAlignImages()` function. This is typically required when; (1) the tissue is bigger than the image and therefore outside the frame, (2) the tissue has a symmetrical shape (for example if the tissue has a round shape, it will be difficult to find an optimal alignment using the tissue edges), (3) the masking has failed.

The actual transformation is done using the `imwarp()` function from the imager R package using a "backward" transformation strategy. This method makes sure that every pixel is painted using linear interpolation so the aligned images will experience some quality loss.
<br>
```{r align_images, fig.width=12, fig.height=12, eval = FALSE}

se <- AlignImages(se)

```
<br>
And the result:
<br>
```{r imageplot_1, fig.width=11, fig.height=6, out.width = '100%'}

ImagePlot(se, method = "raster", darken = T)

```


#### Manual rigid transformations

An alternative method is to apply rigid transformations to the images using the `WarpImages()` function. This function takes a list of transformations for the samples of your choice and converts the transformations into mapping functions which can be used to warp the images. 

The available transformations are; "center.x", "center.y", "mirror.x", "mirror.y" and "angle"
<br>
```{r warpimages, fig.width=12, fig.height=6, out.width = '100%'}

transforms <- list("2" = list("angle" = 90))
se.rotate90 <- WarpImages(se, transforms)
ImagePlot(se.rotate90, method = "raster", darken = T)

transforms <- list("2" = list("mirror.x" = T))
se.mirrorx <- WarpImages(se, transforms)
ImagePlot(se.mirrorx, method = "raster", darken = T)

transforms <- list("2" = list("mirror.y" = T))
se.mirrory <- WarpImages(se, transforms)
ImagePlot(se.mirrory, method = "raster", darken = T)

```
<br>
Any transformations applied to the images will also be applied to the coordinates used to map gene expression values onto the images. 
<br>
```{r show_warp, fig.height=6, fig.width=12, out.width = '100%'}

heatmap.colors <- c("black", "dark blue", "cyan", "yellow", "red", "dark red")
ST.FeaturePlot(se, features = "Cck", pt.size = 0.5, cols = heatmap.colors, dark.theme = T)
ST.FeaturePlot(se.rotate90, features = "Cck", pt.size = 0.5, cols = heatmap.colors, dark.theme = T)
ST.FeaturePlot(se.mirrorx, features = "Cck", pt.size = 0.5, cols = heatmap.colors, dark.theme = T)
ST.FeaturePlot(se.mirrory, features = "Cck", pt.size = 0.5, cols = heatmap.colors, dark.theme = T)

```

### Visualize multiple samples

If you still want to plot overlaid spatial heatmaps for multiple samples at the same time you can do this with the `MultiFeatureOverlay()` function. 
<br>
```{r overlay_multi, fig.width=12, fig.height = 6, out.width = '100%'}

MultiFeatureOverlay(se, features = "Nrgn", 
                    sampleids = 1:2,
                    pt.size = 0.5, pt.alpha = 0.5,
                    cols = c("black", "dark blue", "cyan", "yellow", "red", "dark red"),
                    method = "raster",
                    dark.theme = T)

```
<br>
The `type` parameter can also be set in the `FeatureOverlay()` function to override the default use of processed images. 
<br>
```{r overlay_multi_raw, fig.height = 6, fig.width = 12, out.width = '100%'}

FeatureOverlay(object = se, features = c("Nrgn", "Cck"), 
               cols = c("black", "dark blue", "cyan", "yellow", "red", "dark red"), 
               pt.size = 0.5, 
               pt.alpha = 0.5,
               sample.index = 2,
               type = "raw", 
               dark.theme = T)

```


## Normalization and scaling

---

Each spot in a Spatial Transcriptomics dataset typically contains RNA from a mixture of cells so why would we apply a workflow that was developed for single-cell RNAseq data? We can calculate some properties to visually inspect the data to see that ST data have similar properties to that of scRNAseq data.
<br>
```{r poisson_comparison, fig.width = 4, fig.height = 8, cache=TRUE}

library(Matrix)
library(magrittr)
library(dplyr)
library(ggplot2)

# Get raw count data 
umi_data <- GetAssayData(object = se, slot = "counts", assay = "RNA")
dim(umi_data)

# Calculate gene attributes
gene_attr <- data.frame(mean = rowMeans(umi_data),
                        detection_rate = rowMeans(umi_data > 0),
                        var = apply(umi_data, 1, var), 
                        row.names = rownames(umi_data)) %>%
  mutate(log_mean = log10(mean), log_var = log10(var))

# Obtain spot attributes from Seurat meta.data slot
spot_attr <- se[[c("nFeature_RNA", "nCount_RNA")]]

p1 <- ggplot(gene_attr, aes(log_mean, log_var)) + 
  geom_point(alpha = 0.3, shape = 16, color = "white") + 
  geom_density_2d(size = 0.3) +
  geom_abline(intercept = 0, slope = 1, color = 'red') +
  ggtitle("Mean-variance relationship") + DarkTheme()

# add the expected detection rate under Poisson model
x = seq(from = -2, to = 2, length.out = 1000)
poisson_model <- data.frame(log_mean = x, detection_rate = 1 - dpois(0, lambda = 10^x))
p2 <- ggplot(gene_attr, aes(log_mean, detection_rate)) + 
  geom_point(alpha = 0.3, shape = 16, color = "white") + 
  geom_line(data = poisson_model, color='red') +
  ggtitle("Mean-detection-rate relationship") + DarkTheme()

cowplot::plot_grid(p1, p2, nrow = 2)

```

We can see from the mean-variance and Mean-detection-rate scatter plots that genes show overdispersion compared to what would be expected under a Poisson model. Because these properties are shared between ST and scRNAseq data we have reasoned that the workflow presented in the Seurat package should be applicable for ST data as well. It is important however to keep in mind that each spots contains a mixture of cell types and should be interpreted as a morphological unit in the context of a tissue section. 

In order to normalize the data we recommend using [variance stabilized transformation](https://www.biorxiv.org/content/10.1101/576827v1) available in the SCTransform function in Seurat as of v3.0. 

Following the rationale expressed above, we transform the data according to the Seurat workflow. Note: for comprehensive tutorials in the different options and workflow possibilities available within Seurat, we recommend looking at their website https://satijalab.org/seurat/  
<br>
```{r SCTransform, warning=FALSE, message=FALSE, results="hide", eval = FALSE} 

se <- SCTransform(se, vars.to.regress = c("sample_id", "nFeature_RNA"))

```

## Finding spatial expression patterns and areas of interest

The strength of untargeted whole transcriptome capture is the ability to perform unsupervised analysis and the ability to find spatial gene expression patterns. We've found good use of the dimensionality reduction method "ICA" (Independent Component Analysis) to find spatial expression patterns. An example is demonstrated below:
<br>
```{r ICA, fig.width=16, fig.height=10, eval = FALSE}

se <- RunICA(se)

``` 
<br>
Different dimensionality reductions methods are supported via Seurat (`RunPCA()`, `RunTSNE`, `RunICA()`, `runUMAP()` ) and the output are stored in the Seurat object. 

We can then plot a variable number of dimensions across the samples.
<br>
```{r dimplot, fig.height=28, fig.width=16, out.width = "100%"}

ST.DimPlot(se, 
           dims = c(-1, 2, -3, -4, 5, -6, 7, -8, 9, 10, 11, 12, -13, 14, 15, -16), # If we flip the sign, the ICA vector will be inverted
           ncol = 8, # Sets the number of columns at dimensions level
           grid.ncol = 2, # Sets the number of columns at sample level
           reduction = "ica", 
           dark.theme = T, 
           pt.size = 0.5, 
           center.zero = T, 
           palette = "MaYl")

```

<br>
To extract the genes that drives the separation according to the dimensionality reduction, we can use the `ProjectDim()` function. Where we specify the dimensions of interest (here IC_1 and IC_3, which are regions that seems to confer a clear spatial expression histology. 
<br>
```{r project_dim}

ProjectDim(se, reduction = "ica", dims = c(1, 2, 4, 5))

```


## Clustering

Clustering is a standard procedure in genomic analysis, and the methods for doing so are numerous. Here we demonstrate an example where we use the result of ICA to perform clustering. In the previous section, we demonstrated how to plot a subset of dimensions from the ICA output. Going through this list, we can notice the dimensions that are "spatially active", i.e. that seems to confer a spatial pattern along their axis. We can extract these dimensions:
<br>
```{r keep_dims, fig.width=16, fig.height=10}
keep.dims <- c(1:12, 16:18, 21:28, 30:34, 40:41, 47, 49:50)
```
<br>
And then use them to construct a Shared Nearest Neighbor (SSN) Graph. 
<br>
```{r findneighbours, eval=FALSE}
se <- FindNeighbors(object = se, dims = keep.dims, verbose = FALSE, reduction = "ica")
```
<br>
Followed by clustering using a modularity optimizer
<br>
```{r findclusters, eval=FALSE}
se <- FindClusters(object = se, verbose = FALSE)
```
<br>
And plotting of the clusters spatially
<br>
```{r plot_clusters, fig.height = 5, fig.width = 10, out.width='100%'}

tol18rainbow <-  c("#771155", "#AA4488", "#CC99BB", "#114477", "#4477AA", "#77AADD", "#117777", "#44AAAA", "#77CCCC", "#777711", "#AAAA44", "#DDDD77", "#774411", "#AA7744", "#DDAA77", "#771122", "#AA4455", "#DD7788")

se[["clusters_ICA"]] <- se[["seurat_clusters"]]
ST.FeaturePlot(object = se, features = "clusters_ICA", dark.theme = T, cols = tol18rainbow, pt.size = 0.5)

```
<br>
```{r clusters_UMAP, fig.height=6, fig.width=8}

se <- SetIdent(se, value = "clusters_ICA")
DimPlot(se, reduction = "umap", cols = tol18rainbow) + DarkTheme()

```

<br>
If you think that the distribution of clusters gets too cluttered, you can also split the view so that only one cluster at the time gets colored.
<br>
```{r plot_clusters_split, fig.height = 12, fig.width = 14, out.width='100%'}

ST.FeaturePlot(object = se, features = "clusters_ICA", dark.theme = T, cols = tol18rainbow, pt.size = 0.1, split.labels = T, indices = 1)

```
<br>
We can take a look a specific look at the most variable features.
<br>
```{r variable_features, fig.width = 13, fig.height = 6}

head(se@assays$SCT@var.features, 20)
top <- se@assays$SCT@var.features

fts <- c("Slc18a2", "Prkcd", "Opalin", "Lamp5")
for (ftr in fts) {
  print(MultiFeatureOverlay(se, 
                    features = ftr, 
                    sampleids = 1:2,
                    cols = heatmap.colors,
                    method = "raster", 
                    pt.size = 0.5, 
                    pt.alpha = 0.5, 
                    dark.theme = T))
}

```
<br>
Another useful feature is that you can now compare the spatial distribution of a gene with the typical "graph embeddings" s.a. UMAP and t-SNE. 
<br>
```{r run_UMAP, eval=FALSE}

# Run UMAP
se <- RunUMAP(se, reduction = "ica", dims = keep.dims, n.neighbors = 10)

````

```{r embedding_vs_ST, fig.width = 16, fig.height = 20}

# Define colors for heatmap
heatmap.colors <- c(rgb(40, 40, 40, maxColorValue = 255), "dark blue", "cyan", "white")
fts <- c("Slc18a2", "Prkcd", "Opalin", "Lamp5")

# plot transformed features expression on UMAP embedding
p.fts <- lapply(fts, function(ftr) {
  FeaturePlot(se, features = ftr, reduction = "umap", order = TRUE, cols = heatmap.colors) + DarkTheme()
})

# plot transformed features expression on Visium coordinates
p3 <- ST.FeaturePlot(se, features = fts, ncol = 2, grid.ncol = 1, cols = heatmap.colors, pt.size = 0.5, dark.theme = T)

# Construct final plot
cowplot::plot_grid(cowplot::plot_grid(plotlist = p.fts, ncol = 1), p3, ncol = 2, rel_widths = c(1, 2))

```

## RGB dimensionality reduction plots

One approach to visualize the result of dimensionality reduction is to use the first three dimensions and transform the values into RGB color space. This 3 dimensional space can then be utilized for spatial visualization.
We demonstrate the technique with UMAP, using our ICA dimensions as input:
<br>
```{r UMAP, val=FALSE}

se <- RunUMAP(object = se, dims = keep.dims, verbose = FALSE, n.components = 3, reduction = "ica", reduction.name = "umap.3d")

```
<br>
We use the first three dimensions for plotting:
<br>
```{r UMAP_blend, fig.height = 6, fig.width = 12}

ST.DimPlot(object = se, dims = 1:3, reduction = "umap.3d", blend = T, dark.theme = T, pt.size = 0.5)

```

<br>
Once again the `ProjectDim()` function can be used to display the genes that are most strongly correlated with the coordinate system. Note in the function call above that we defined `reduction.name`, which are subsequently stored in the Seurat object in the reduction slot: 
<br>
```{r projectdim_UMAP}

ProjectDim(se, reduction = "umap.3d")

```
<br>
As seen in the plot above, there are clear spatial patterns that are confirmed by the histology of the tissue. 
Lets take an example, looking at the first UMAP coordinate (red color) - we note a clear pattern [bra beskrivning av vad vi ser]

We can utilize an external data source, the Allen brain atlas, to see how well our data match. 
Lets take the gene with highest correlation to the red color, i.e. "Cck". 

https://mouse.brain-map.org/gene/show/12209
![Expression data - Allen brain atlas](Allen_expression_data.PNG)

![ISH data - Allen brain atlas](Allen_ISH_data.PNG)
<br>
```{r allen_example, fig.width = 13, fig.height = 6}

MultiFeatureOverlay(se, features = "Cck", 
                    sampleids = 1:2,
                    cols = c("black", "dark blue", "cyan", "yellow", "red", "dark red"),
                    pt.size = 0.5, 
                    pt.alpha = 0.5,
                    method = "raster", 
                    dark.theme = T)

```


## Factor Analysis

If you want to explore underlying expression patterns of a tissue sample it can sometimes be useful to decompose the expression matrix into factors. Here we describe how to run a Non-negative Matrix Factorization on Spatial Transciptomics using the `RunNMF()` function. One key advantage of the NMF method, compared to e.g. PCA, is that the factors are additive, i.e. every point in the transformed space can be contructed by adding together strictly positive features. This feature of the NMF factors helps a lot to increase the interpretability. 

The method provided in this package is largely inspired by the `RunNMF()`function provided in the [swne R package](https://github.com/yanwu2014/swne) by [Wu et al (2018)](https://www.cell.com/cell-systems/fulltext/S2405-4712(18)30440-X).
<br>

```{r source_NMF, include = FALSE}
source(file = "~/STUtility_backup/R/NMF_global_functions.R")
```

```{r NMF, eval=F}

se <- RunNMF(se, n.cores = 7, nfactors = 20)

```

### Visualize factors

Now we can visualize the factors on the Visium array coordinates to explore their spatial distribution.

<br>
```{r dimplot_NMF, fig.height=110, fig.width=12, out.width = "100%"}

ST.DimPlot(se, 
           dims = 1:20, 
           ncol = 8, 
           grid.ncol = 1, 
           reduction = "NMF", 
           dark.theme = T, 
           pt.size = 0.5, 
           center.zero = F, # important to set, otherwise the data is expected to be centered at 0
           cols = c("black", "dark blue", "cyan", "yellow", "red", "dark red"))

```
<br>

Again, we can use the NMF factors as a dimensionality reduction input for clustering and embedding in UMAP.

```{r UMAP_on_NMF}

se <- FindNeighbors(object = se, dims = 1:20, verbose = FALSE, reduction = "NMF") %>%
  FindClusters(verbose = FALSE) %>% 
  RunUMAP(reduction = "NMF", dims = 1:20, n.neighbours = 20, reduction.name = "umap.NMF")

```

When plotting the clusters on the Visium array coordinates we can see similar clusters as before. 
<br>
```{r plot_clusters_NMF, fig.height = 5, fig.width = 10, out.width='100%'}

se[["clusters_NMF"]] <- se[["seurat_clusters"]]
ST.FeaturePlot(object = se, features = "clusters_ICA", dark.theme = T, cols = tol18rainbow, pt.size = 0.5)

```
<br>
If we split the clusters it seems as if we can find more patterns than before.
<br>
```{r plot_clusters_split_NMF, fig.height = 12, fig.width = 14, out.width='100%'}

ST.FeaturePlot(object = se, features = "clusters_NMF", dark.theme = T, cols = tol18rainbow, pt.size = 0.1, split.labels = T, indices = 1)

```
<br>
Below is a visualization of the clusters on a UMAP embedding.
<br>
```{r clusters_UMAP_NMF, fig.height=6, fig.width=8}

se <- SetIdent(se, value = "clusters_NMF")
DimPlot(se, reduction = "umap.NMF", cols = tol18rainbow) + DarkTheme()

```

### HSV color mode

If we wish to visualize the values of multiple features simultaneously we can use the "color blend" trick to color code each spot in the RGB channels. This trick allows us to visualize up to three features at once and has the advantage that spots with a mixture of different feature values will be represented by the mixing in color as well. For example, if you want to explore the spatial distribution of two features A and B, you can squeeze these values into the "red" and "green" color channels to create color codes for each spot. If A is present but not B, the color will be "red" and "green" if B is present but not A. If A and B are mixed, the color will anything between "red" and "green" where a 50/50 mixture gives a "yellow" color. The downside of this trick is that you cannot encode more than three features this way because for obvious reasons. 

However, if we know that the features we are looking do _NOT_ mix across spots (or at least very little), we could assign a color to each feature separately and select the color with the highest feature value for each spot. To do this, we can for example use the HSV color scale. 
<br>
```{r HSV, fig.width=6, fig.height=12, out.width='100%'}

factors.use <- c(1:5, 7:11, 13, 18, 20)
HSVFeaturePlot(object = se, features = paste0("factor_", factors.use), ncol = 1)

```
<br>
We can also look at the top contributing genes for each factor to get a sense of what the factors represent.
<br>
```{r factor_heatmap, fig.width=10, fig.height=7}
library(zeallot)
c(top.factor.genes.df, gene.loadings) %<-% SummarizeAssocFeatures(object = se, features.return = 3)
swne::ggHeat(m = gene.loadings[, paste0("factor_", 20:1)], heatscale = c("black", rgb(0, 0, 60, maxColorValue = 255), "yellow"), rescaling = "column") + coord_flip() + DarkTheme()

```


[To be added soon]
 
# QC

---

We recommend to do create some general plots and statistical views of the data before diving further into analysis. This will act as a sanity check on the obtained data, and can immediately reveal eventual artifacts as batch effects or missing data.

### Scatter plots

We start off by doing a simple scatter correlation plot of the average expression across the samples. In this case, we are looking at 8 consecutive tissue sections. Accordingly, they should display a quite high correlation across all samples. 
<br>
```{r corplot, fig.width=24, fig.height=24}

Idents(se) <- "sample_id"
avg.exp <- AverageExpression(se, return.seurat = F, verbose = T, add.ident = "sample_id")
pairs(log(avg.exp$SCT))


```

### Nr transcripts/unique genes

```{r QC, cache=TRUE}

ggplot(data.frame(counts=se$nCount_RNA, sample = se$sample_id, stringsAsFactors = T), aes(counts))+
  geom_histogram(bins=50, fill = "white", colour="black")+
  facet_wrap(~sample, scales = 'free_y')+
  geom_vline(xintercept = mean(se$nCount_RNA), color = "red", linetype = "dashed")+
  theme_bw()+ggtitle("Total Raw Transcripts")


ggplot(data.frame(counts=se$nFeature_RNA, sample = se$sample_id, stringsAsFactors = T), aes(counts))+
  geom_histogram(bins=50, fill = "white", colour="black")+
  facet_wrap(~sample, scales = 'free_y')+
  geom_vline(xintercept = mean(se$nFeature_RNA), color = "red", linetype = "dashed")+
  theme_bw()+ggtitle("Total UMI counts")

```

### Checking known expression patterns 

If the experiment at hand involves tissue sections with well-defined anatomical structure, one of the most obvious sanity checks is to simply plot the expression values of structural marker genes which should be differentially expressed between the anatomical structures. An example of this is shown below on a MOB sample. From empirical evidence we know _a priori_ that [insert gene names] are expressed [insert region]. By examining the expression patterns of these known genes, we can also assess if there is any evidence for horizontal diffusion or contamination which would indicate an experimental failure. 

This check is of course only possible if the tissue section(s) has/have such defined structure. Nevertheless, one could with a bit of imagination often perform this kind of checks even for more homogeneous samples, e.g. "I know that this genes should definitely be present/not present in my sample" etc. 
<br>
```{r plot_markers, fig.height=6, fig.width=12}
library(ggplot2)

ST.FeaturePlot(object=se,
               features="Nrgn",
               palette = "GrRd",
               delim = "x|_",
               pt.size = 1,
               dark.theme = T)

```

### Checking for batch effects

The dimensionality reduction (e.g. via UMAP) projection onto RGB space works excellent as a batch effect check. Here we show four samples of mouse hippocampus that clearly display a batch effect subject to samples prepared on different arrays:
<br>
```{r batch_effects, eval=FALSE, echo=FALSE}

#THIS PART IS NOW REMOVED
#Load hippo samples

infoTabel2 <- read.table("~/STUtility/inst/extdata/metaData_hippo_batch_check.csv", sep=";", header=T, stringsAsFactors = F)
se.batch.effect <- prep.from.table(infotable = infoTabel2, 
                      transpose = F, 
                      min.gene.count = 100, 
                      min.gene.spots = 5,
                      min.spot.count = 500, 
                      spot.file = FALSE)

#Perform Seurat transform
se.batch.effect <- SCTransform(se.batch.effect, 
                               vars.to.regress = c("sample_id", "nFeature_RNA"),
                               verbose = F)


se.batch.effect <- RunICA(se.batch.effect, verbose = FALSE)
se.batch.effect <- RunUMAP(object = se.batch.effect, dims = 1:50, verbose = FALSE, n.components = 3, reduction = "ica", reduction.name = "umap.3d")

gg <- ST.DimPlot(object = se.batch.effect, dims = 1:3, 
           reduction = "umap.3d", blend = T, 
           dark.theme = T,
           delim="x|_")


# ---------------------------------------------------------------------------------
```


Correction of batch effects

---

```{r}

#LL

```


# Supervised DEA between regions

## Manual annotation

STUtility include two different alternatives for manual annotation of the tissue. 

## Interactive plot via Shiny application

There is a slot in `se@meta.data$labels`, which is created to store any labels the user wants to associate with each capture-spot.         
By default, all label slots are populated by "Default". New labels are easily added based on transcript data (e.g. count values or clusters assignments) by standard R operations. The interactive Shiny applications is used to make manual annotation based on morphology. 

To load the Shiny application:

```{r manual_annotation, eval=FALSE}

ManualAnnotation(se)

```

This will by default open the application in the standard browser, and the first sample will be displayed. Follow the instructions provided in the application to place labels accordingly.

![](manual_annotation.png)

NB: The images used for the manual annotation are loaded as _raw images_ from the image paths provided. This implies that it might take some time to start the application, changing samples and confirming selections, since all those actions load images. By default the images will be loaded at a resolution of 1500pixels. If the loading of images takes to long, the parameter `res` can be set to a lower resolution.  

## Annotation by providing colored images

### Using the annotations to extract specific caputure-spots

[add info - subset spots]

### Using the annotations for Seurat workflow DEG analysis

The manual annotations could e.g. be used for supervised analysis of gene expression markers. Within Seurat it's easy to conduct such analysis by first setting the capture-spots identity classes to the annotation level. 

```{r set_idents_to_labels, eval=FALSE}

Idents(se) <- se@meta.data$labels

```

Remember, the labels include _all_ capture-spots, which by default have label "Default". To conduct DEA for the identity classes, we utilize the `FindMarkers()` function, and specify the two different levels which we want to compare against.

```{r de_markers, eval=FALSE}

de.markers <- FindMarkers(se, ident.1 = "Epithelial", ident.2 = "Stroma")

head(de.markers)

```

Excluding `ident.2` results in differential expression between one group vs all other capture-spots.

```{r epithelial_markers, eval=FALSE}

FindMarkers(se, ident.1 = "Epithelial")

```

See https://satijalab.org/seurat/v3.0/de_vignette.html for various pre-filter options that can be used to increase the speed of the DE test as well as conducting the DE analysis using alternative tests.

# Other situations, tips & tricks

## Extraction of data

The core of STUtility is the Seurat object, where all information from the different functions are saved. Accordingly, it's convenient to extract this information by opening the different slots within the object. See https://satijalab.org/seurat/ for extensive information.

## Subsetting - the plots are not looking good after subsetting the Seurat object!

We know, in the current version of STUtility, it's required to run `LoadImages()` again after subsetting.

## What if I don't have spot file coordinates?

No problem. However, the count matrix needs to have some sort of coordinate info in order to actually plot the data spatially. Normally this information is kept in the colnames of the count matrix, e.g. "XxY" with X=xcoordinate and Y=ycoordinate. Creating the Seurat object with the `prep.from.table` function will result in the addition of "_z" to the column names of the input matrix, where "z" is the sample number. When calling the spatial plots (i.e. ST.xxxPlot), use the parameter `delim` to specify the type of colnames you have in the Seurat object. If the names are according to the outline above, this would imply `delim = "x|_"`.  

## Playing around with colors

- blend T
- channel.use
flippa ordningen på rgb
eg Chanels.use = c("green", "blue", "red")
- smooth
- tesselation
- Capping the legends (heatmap)

## I used the RGB projection technique, but find it hard to wrap my head around the color contribution of the blend

The colors of each capture-spot can be extracted, but might be a bit inconvenient to look at multiple areas. We propose the following procedure if you want to "hover around" the plot and look at the R, G and B contribution to see where in the 3Dim space the capture spot is located. This make use of the R package `plotly`. See example code below.

```{r, eval=FALSE, echo=TRUE}
library(plotly)
gg <- ST.DimPlot(object = se, dims = 1:3, reduction = "umap.3d", blend = T, dark.theme = T, pt.size=3)
ggBuild <- ggplot_build(gg)
rgbTransform <- as.data.frame(t(col2rgb(ggBuild$data[[1]]$colour))) #Here you can find all the colors

#We can also use these to plot an interactive plot with the colors as hover tooltip:
gg$layers[[1]]$mapping$rgbs <- paste("R:", round(rgbTransform$red/2.55), 
                                          "% G:", round(rgbTransform$green/2.55), 
                                          "% B:", round(rgbTransform$blue/2.55), "%",
                                          sep="")

dark_theme <- function() {
  theme(plot.background = element_rect(fill = "black"),
        plot.title = element_text(colour = "white"),
        strip.text = element_text(colour = 'white'),
        legend.title = element_text(colour = "white"),
        legend.text = element_text(colour = "white"))
}


ggplotly(gg + dark_theme() , tooltip="rgbs") #This will open the interactive view plane


```

## Saving of images to a pdf file

For saving images, we usually use the built in function `pdf()` within R. All plotting functions in STutility returns a ggplot object. Accordingly just, initiate the pdf function, make the plot and then turn off the graphic device:

```{r RGB_on_batch_correcetd, eval=FALSE}

pdf("nameOfyourImage.pdf", width = 12, height = 12)

ST.DimPlot(object = se, dims = 1:3, reduction = "umap.3d", blend = T, dark.theme = T)

dev.off()

```

# Acknowledgements

STUtility relies heavily on the Seurat package, currently version 3.0 As such, we would like to take the opportunity to thank the excellent folks at Satija Lab for their efforts and contribution to the space. The bioinformatic folks at Scilifelab working on Spatial Transcriptomics from the early days of it's inception have gone over numerous ways of handling this type of data in our never ending pursuit of placing transcriptomic information in its spatial context. So far, the Seurat approach to transformation demonstrated here is our preferred method. Furthermore, we picture that the suitability will not deteriorate when the capture spot resolution of the spatial methods keeps getting smaller and smaller in size, eventually reaching the single-cell level that Seurat in reality is developed for to begin with. 




&nbsp;
<hr />
<p style="text-align: center;">A work by <a href="j.bergenstrahle@scilifelab.se">Joseph Bergenstråhle</a> and <a href="ludvig.larsson@scilifelab.se">Ludvig Larsson</a></p>

<!-- Add icon library -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

<!-- Add font awesome icons -->
<p style="text-align: center;">
    <a href="https://www.spatialresearch.org" class="fa fa-beer"></a>
</p>

&nbsp;
