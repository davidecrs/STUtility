% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Visualization.R
\name{FeatureOverlay}
\alias{FeatureOverlay}
\title{Visualize 'features' on an ST array grid overlayed on top of HE image}
\usage{
FeatureOverlay(object, features, sample.index = 1, spots = NULL,
  type = NULL, min.cutoff = NA, max.cutoff = NA, slot = "data",
  blend = FALSE, pt.size = 2, pt.alpha = 1, shape.by = NULL,
  palette = NULL, cols = NULL, grid.ncol = NULL,
  center.zero = FALSE, channels.use = NULL, verbose = FALSE,
  split.labels = FALSE, dark.theme = FALSE, sample.label = TRUE,
  show.sb = TRUE, value.scale = c("samplewise", "all"), ...)
}
\arguments{
\item{object}{Seurat object}

\item{features}{\itemize{
    \item An \code{Assay} feature (e.g. a gene name - "MS4A1")
    \item A column name from meta.data (e.g. mitochondrial percentage - "percent.mito")
}}

\item{sample.index}{Index specifying the sample that you want to use for plotting}

\item{spots}{Character vector with spot IDs to plot [default: all spots]}

\item{type}{Image type to plot on. Here you can specify any of the images available in your Seurat object. To get this list you can
run the \code{\link{rasterlists}} function on your Seurat object. If the type is not specified, the images will be prioritized in the following
order if they are available; "processed", "masked" and "raw".}

\item{min.cutoff}{Vector of minimum and maximum cutoff values for each feature, may specify quantile in the form of 'q##' where '##'
is the quantile (eg, 'q1', 'q10'). This can be useful if you have outlier values that skew the colorscale in the plot. For example, if you specify
'q1', you will trim of values below the 1st percentile. [default: no cuttoffs]}

\item{max.cutoff}{Vector of minimum and maximum cutoff values for each feature, may specify quantile in the form of 'q##' where '##'
is the quantile (eg, 'q1', 'q10'). This can be useful if you have outlier values that skew the colorscale in the plot. For example, if you specify
'q1', you will trim of values below the 1st percentile. [default: no cuttoffs]}

\item{slot}{Which slot to pull expression data from? [dafault: 'data']}

\item{blend}{Scale and blend expression values to visualize coexpression of two features (this options will override other coloring parameters).
See 'Blending values' below for a more thourough description.}

\item{pt.size}{Point size of each ST spot [default: 1]}

\item{pt.alpha}{Opacity of each ST spot [default: 1]}

\item{shape.by}{String specifying the column where the shaping label is stored}

\item{palette}{Color palette used for spatial heatmap (see \code{palette.select(info = T)} for available options).
Disabled if a color vector is provided (see \code{cols} below).}

\item{cols}{A vector of colors to use for colorscale, e.g. \code{cols = c("blue", "white", "red")} will
create a gradient color scale going from blue to white to red. This options will deactivate the \code{palette}
option.}

\item{grid.ncol}{Number of columns for display when combining plots. This option will only have an effect on the sample level structure.}

\item{center.zero}{Specifies whther or not the colorscale should be centered around 0. For some values, such as Principal Component vectors,
the distribution of values is centered at 0 and in that case it can be appropriate to use a divergent colorscale with a predefined value for 0.
If this parameter is set to TRUE, the ggplot2 function \code{scale_color_gradient2} will be used to control the coloring instead of
\code{scale_color_gradientn}. If center.zero is set to FALSE, the colorscale will simply map the values in equally spaced intervals which could skew
the interpretaion of the output plot.}

\item{channels.use}{Color channels to use for blending. Has to be a character vector of length 2 or 3 with "red", "green" and "blue"
color names specified [default: c("red", "green", "blue)]}

\item{verbose}{Print messages}

\item{split.labels}{Only works if the features are specified by character vectors.
The plot will be split into one plot for each group label, highlighting the labelled spots.}

\item{dark.theme}{Switches color of scalebar to 'white'}

\item{sample.label}{Should the sample label be included in the image? [default: TRUE]}

\item{...}{Extra parameters passed on to \code{\link{ST.ImagePlot}}}
}
\value{
A ggplot object
}
\description{
Colors spots on an an ST array grid according to a 'feature'
(i.e. gene expression (raw counts or scaled) and features available in the meta data slot)
}
\examples{

# Load images
se <- LoadImages(se)

# Overlay the number of unique genes and the number of UMIs per spot on sample 1 HE image
FeatureOverlay(se, features = c("nFeature_RNA", "nCount_RNA"), sample.index = 1)

# Plot selected genes
FeatureOverlay(se, features = c("Cck", "Dcn"), sample.index = 1)

# Plot normalized values
se <- SCTransform(se)
FeatureOverlay(se, features = c("Cck", "Dcn"), sample.index = 1)

# Change to scaled data
FeatureOverlay(se, features = c("Cck", "Dcn"), sample.index = 1, slot = "scale.data", center.zero = TRUE)

# Mask images and plot plot the slected genes on the masked image
se <- MaskImages(se)
FeatureOverlay(se, features = c("Cck", "Dcn"), sample.index = 1, type = "masked")

}
\seealso{
\code{\link{ST.FeaturePlot}} and \code{\link{ST.DimPlot}} for how to plot features
without the HE image, \code{\link{DimOverlay}} for how to overlay dimensionality reduction output on the
HE images and \code{\link{MultiFeatureOverlay}} and \code{\link{MultiDimOverlay}} for how
to overlay plots on the HE images in multiple samples.
}
