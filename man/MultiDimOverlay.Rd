% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Visualization.R
\name{MultiDimOverlay}
\alias{MultiDimOverlay}
\title{Apply DimOverlay to multiple samples}
\usage{
MultiDimOverlay(object, sampleids, spots = NULL, ncols.dims = NULL,
  ncols.samples = NULL, dims = c(1:2), type = NULL,
  min.cutoff = NA, max.cutoff = NA, blend = FALSE, pt.size = 1,
  pt.alpha = 1, reduction = NULL, shape.by = NULL,
  palette = "MaYl", cols = NULL, center.zero = FALSE,
  channels.use = NULL, verbose = FALSE, dark.theme = FALSE, ...)
}
\arguments{
\item{object}{Seurat object}

\item{sampleids}{Integer vector specifying sample indices to include in the plot}

\item{spots}{Character vector with spot IDs to plot [default: all spots]}

\item{ncols.dims}{Number of columns passed to \code{\link{DimOverlay()}}. For example,
if you are plotting 4 dims, `ncols.dims = 2` will arrange the \code{\link{DimOverlay()}}
plots into a 2x2 grid [default: `length(dims)`]. (see \emph{Arrange plots*} for a detailed description)}

\item{ncols.samples}{Number of columns in the layout grid for the samples. For example,
if you are plotting 4 samples, `ncols.samples = 2` will arrange the plots obtained
from \code{\link{DimOverlay()}} plots into a 2x2 grid [default: `1`].
(see \emph{Arrange plots} for a detailed description)}

\item{dims}{List of dimensions for original images. This list has to contain one element for each sample and each element
should be a vector of length 2 specifying the dimensions of the original HE image.}

\item{type}{Image type to plot on. Here you can specify any of the images available in your Seurat object. To get this list you can
run the \code{\link{rasterlists}} function on your Seurat object. If the type is not specified, the images will be prioritized in the following
order if they are available; "processed", "masked" and "raw".}

\item{min.cutoff}{Vector of minimum and maximum cutoff values for each feature, may specify quantile in the form of 'q##' where '##'
is the quantile (eg, 'q1', 'q10'). This can be useful if you have outlier values that skew the colorscale in the plot. For example, if you specify
'q1', you will trim of values below the 1st percentile. [default: no cuttoffs]}

\item{max.cutoff}{Vector of minimum and maximum cutoff values for each feature, may specify quantile in the form of 'q##' where '##'
is the quantile (eg, 'q1', 'q10'). This can be useful if you have outlier values that skew the colorscale in the plot. For example, if you specify
'q1', you will trim of values below the 1st percentile. [default: no cuttoffs]}

\item{blend}{Scale and blend expression values to visualize coexpression of two features (this options will override other coloring parameters).
See 'Blending values' below for a more thourough description.}

\item{pt.size}{Point size of each ST spot [default: 1]}

\item{pt.alpha}{Opacity of each ST spot [default: 1]}

\item{reduction}{Which dimensionality reduction to use. If not specified, first searches for "umap", then "tsne", then "pca"}

\item{shape.by}{String specifying the column where the shaping label is stored}

\item{palette}{Color palette used for spatial heatmap (see \code{palette.select(info = T)} for available options).
Disabled if a color vector is provided (see \code{cols} below).}

\item{cols}{A vector of colors to use for colorscale, e.g. \code{cols = c("blue", "white", "red")} will
create a gradient color scale going from blue to white to red. This options will deactivate the \code{palette}
option.}

\item{center.zero}{Specifies whther or not the colorscale should be centered around 0. For some values, such as Principal Component vectors,
the distribution of values is centered at 0 and in that case it can be appropriate to use a divergent colorscale with a predefined value for 0.
If this parameter is set to TRUE, the ggplot2 function \code{scale_color_gradient2} will be used to control the coloring instead of
\code{scale_color_gradientn}. If center.zero is set to FALSE, the colorscale will simply map the values in equally spaced intervals which could skew
the interpretaion of the output plot.}

\item{verbose}{Print messages}

\item{...}{Parameters passed to DimOverlay}
}
\description{
Apply DimOverlay to multiple samples
}
\section{Arrange plots}{


\code{\link{MultiDimOverlay()}} will first draw one plot for all `dims` in each sample using
\code{\link{DimOverlay()}}. The `ncols.dims` argument will determine how each subplot called using
\code{\link{DimOverlay()}} is arranged and will by default put all dims in 1 row, i.e.
`ncols.dims = length(dims)`. The `ncols.samples` argument will determine how these subplots
are arranged and will by default use 1 column, meaning that each subplot is put in its own row.
The output layout matrix would then be `length(samples)*length(dims)`
}

\examples{

# Load images and run PCA
se <- LoadImages(se) \%>\%
   RunPCA()

# Plot the first 2 dimensions on the first two samples
MultiDimOverlay(se, dims = 1:2, reduction = "pca", sampleids = 1:2)

# Blend values for dimensions 1 and 2 on the first two samples
MultiDimOverlay(se, dims = 1:2, reduction = "pca", sampleids = 1:2, blend = T)

# Plot the first 2 dimensions and trim off 1st percentile values on the first two samples
MultiDimOverlay(se, dims = 1:2, reduction = "pca", sampleids = 1:2, min.cutoff = 'q1')

# Mask images and plot the first 2 dimensions on the masked images for samples 1 and 2
se <- MaskImages(se)
MultiDimOverlay(se, dims = 1:2, reduction = "pca", sampleids = 1:2, type = "masked")

}
\seealso{
\code{\link{ST.FeaturePlot}} and \code{\link{ST.DimPlot}} for how to plot features
without the HE image, \code{\link{FeatureOverlay}} and \code{\link{DimOverlay}} for how to
overlay feature plots on the HE images and \code{\link{MultiFeatureOverlay}} and for how
to overlay feature plots on the HE images in multiple samples.
}
